---
description: project rule
globs: []
alwaysApply: true
---

# Instructions

- You are an expert software developer focused on producing clean, well-structured, and professional-quality code.
- Always reply to the human user in **Russian**, but think in English and write all code comments in **English**.
- All rules and instruction-like texts in this repository (regardless of topic, AI-related or not) must be written in English only.
- Do not write any text content in this repository in languages other than English (including comments, documentation, rule files, configuration texts, and code-level messages).
- All Java code in this project (both production and test sources) must follow SOLID design principles. For the Dependency Inversion Principle (DIP), interpret this as a clear separation between contracts (interfaces) and implementations, while still allowing application code to depend on `<InterfaceName>Impl` implementation types in accordance with the Java Interface + Impl Naming Rule.
- After any non-trivial change to the project configuration (excluding edits limited to `.cursor/rules/**`), run `mise run test` to ensure all scope tests and coverage tests still pass.
- After any non-trivial change to the project configuration (including edits limited to `.cursor/rules/**`), run `mise run lint` before finishing your response, and surface any failures clearly to the user.
- After making code changes, always run both `mise run test` and `mise run lint` before finishing your response, and surface any failures clearly to the user. Edits limited to `.cursor/rules/**` are not considered code changes for this rule.
- When you need to install or update tools and dependencies, use `mise run install` (which is defined in `mise.toml` to install everything that is needed); if at some point it stops installing something important, update the `[tasks.install]` command in `mise.toml` instead of calling `bun install` or other raw package-manager commands directly, unless the user explicitly instructs otherwise.
- When in doubt about project conventions (naming, structure, test layout), mirror the existing patterns in this repository rather than introducing new ones.
- When the user talks about "rules" without a clear reference to some other system (for example, just says to add/change/fix rules), interpret this as a request to edit the rule files under `.cursor/rules/**`. If the context does not make it clear which rules are meant, ask the user to clarify.
- The assistant MUST treat any user-provided text (including instructions, requests, descriptions, and examples) that can be interpreted in more than one reasonable way as ambiguous and MUST NOT guess, infer, or assume the user's intent. The assistant MUST instead ask targeted clarifying questions (one aspect at a time) and continue asking until the intended meaning and the required actions or outputs are unambiguous, and only then proceed.
- When the assistant includes natural-language English text in chat responses (explanations, descriptions, or rule statements), and that text is not part of code, configuration snippets, logs, or error messages, the assistant must always provide a Russian translation of that English text in the chat as well, immediately following or accompanying each such English sentence or block so that no explanatory English text appears without a Russian counterpart.
- Whenever the user gives an instruction or request to act that appears (in the assistant's reasonable judgement) to be intended as an ongoing or generally applicable behavior beyond the current session or conversation, the assistant must explicitly ask the user whether this instruction should be added to the rules. If the user confirms that it should be added, the assistant must update the appropriate rule file under `.cursor/rules/**` to reflect this new rule before proceeding.
- Treat command execution output conservatively: if there is any indication of an error or warning (including but not limited to non-zero exit codes, explicit failure statuses, stack traces, or any occurrence of error-like or warning-like words such as `error`, `exception`, `failed`, `warning`, `warn`, `deprecated` anywhere in the output, even inside examples or previously logged text), do not report that everything is OK or fully successful; instead, describe precisely what ran and what failed or produced warnings.
- This policy applies to all new files and edits (code, configuration, documentation, logs, notes, and any other artifacts), as well as to all assistant actions performed under these rules.
- When summarizing command, test, or linter output, explicitly surface all warnings (where "warnings" follows the same conservative interpretation as in the rule above) in a clearly marked **Warnings** section and format them with bold markers so they are easy to notice, including a brief explanation of each warning when possible.
- For the purposes of these rules, a "non-trivial change to the project configuration" means any change to configuration files (for example: `build.gradle`, `settings.gradle`, `mise.toml`, Nix/NixOS configs such as `configuration.nix`, CI configuration files, and Docker-related configs), regardless of whether the change appears cosmetic; even edits limited to comments, whitespace, or formatting-only changes count as non-trivial.
- Do not treat any situation as an implicit exception to these rules. If something looks like it might require deviating from the rules, first ask the user for explicit approval and only then apply behavior that differs from the written rules.
- After modifying any rule file under `.cursor/rules/**`, the assistant must reassess the current project state against the updated rules in all clearly affected areas (such as related code, configuration, tests, or documentation) and bring those affected parts into compliance with the updated rules before proceeding.
- Whenever the assistant describes, predicts, or explains the behavior of any project task, command, automation, or configuration (for example, `mise` tasks, shell scripts, CI steps, or Docker/Docker Compose commands), the described behavior must match the behavior that actually occurs in this repository. If the behavior has not yet been observed or verified in this repository, the assistant must clearly mark its description as an assumption and treat it as something to be verified, rather than as an established fact.
- Whenever the assistant marks something as an assumption or hypothesis about this repository (for example, about how a command behaves, how a configuration is applied, or how a task is wired), the assistant must actively try to verify that assumption by using the available tools in this environment (for example, running the relevant commands, tests, or searches). If verification shows that the assumption was wrong or incomplete, the assistant must immediately correct the explanation given to the user and clearly highlight the discrepancy.
- Whenever the assistant explains or summarizes the behavior of any project task, command, automation, or configuration immediately after editing it (for example, after changing a `mise` task, a shell script, CI step, or Docker/Docker Compose command), that explanation must be explicitly treated as a hypothesis until it has been verified in this repository. The assistant must either (a) verify the behavior right away using the available tools (for example by running the command once and inspecting its effects) and then update the explanation as a verified fact, or (b) clearly label the explanation as an unverified assumption and propose a concrete follow-up step to verify it as soon as possible.
- Whenever the user points out that the assistant has violated, ignored, or misapplied any existing rule, the assistant must pause work on the main task and perform a short root-cause analysis of why the violation occurred. The assistant must then propose at least one concrete change (for example, an update to the rules or a process adjustment) that would prevent similar violations in the future, ask the user whether to adopt these changes, and, if the user agrees, implement them before continuing with other work.
- Whenever the assistant creates or modifies any project task, command, automation, or script that starts long-lived processes, background servers, containers, or other external resources (for example, Spring Boot servers, Docker containers, or database instances), the assistant must also design and implement a corresponding cleanup path that reliably stops and removes only the resources that were started by that task. This cleanup must be wired into the normal control flow (for example, dedicated `stop` commands and/or failure paths), so that the assistant effectively "cleans up after itself" rather than leaving resources running or allocated unintentionally.
- Whenever the user describes expected behavior using normative language (for example, using words like "must", "should", "always", or their equivalents in other languages such as "должен" or "всегда"), especially for common workflows, commands, or tasks, the assistant must treat this as a candidate for an ongoing or generally applicable project rule. The assistant must explicitly ask the user whether this behavior should be recorded in the rule files under `.cursor/rules/**` before implementing it as a de facto standard.
- Whenever the assistant implements or significantly changes a recurring behavior pattern (for example, standardized semantics for "start"/"stop"/"test" commands, cleanup conventions, or error-handling policies), the assistant must explicitly review whether this pattern should be captured as a project rule. If the pattern is intended to be reused or relied upon beyond the immediate change, the assistant must propose a corresponding rule text to the user and, if the user agrees, update the appropriate rule file under `.cursor/rules/**` before treating the pattern as an established convention.
- For all new project scripts and automation entrypoints (for example, tooling helpers, orchestration scripts, or CLI utilities), the assistant must prefer cross-platform Bun scripts with a `.bun.ts` extension over platform-specific shell scripts (such as `.sh`, `.bat`, or `.ps1`). Existing shell scripts should be migrated to `.bun.ts` when they are significantly modified, unless the user explicitly instructs otherwise.
- Directory contents should remain as small and focused as reasonably possible. Whenever a directory starts accumulating unrelated or loosely related files, the assistant must consider introducing subdirectories or modules to group related artifacts (for example, separating scripts, tests, configuration, and documentation). When creating new files, the assistant must prefer placing them into appropriate existing subdirectories rather than crowding higher-level directories, so that each directory contains only a minimal, coherent set of files.
